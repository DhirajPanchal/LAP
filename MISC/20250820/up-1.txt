1------------

// Next-safe localStorage wrapper
import createWebStorage from "redux-persist/lib/storage/createWebStorage";

const createNoopStorage = () => ({
  getItem(_key: string) { return Promise.resolve(null); },
  setItem(_key: string, value: string) { return Promise.resolve(value); },
  removeItem(_key: string) { return Promise.resolve(); },
});

export const persistentStorage =
  typeof window !== "undefined" ? createWebStorage("local") : (createNoopStorage() as any);


2-------------

import { createSlice, PayloadAction } from "@reduxjs/toolkit";
import type { VisibilityState } from "@tanstack/react-table";

export type PageKey = "viewer" | "reviewer" | "approver";
type TableKey = string;

export interface GridPrefs {
  visibility: VisibilityState;
  frozen: string[];            // column IDs
}

type GridPrefsState = {
  [page in PageKey]?: { [table in TableKey]?: GridPrefs };
};

const ALWAYS_VISIBLE = new Set(["select", "id"]);

const sanitize = (prefs: GridPrefs): GridPrefs => {
  const v = { ...(prefs.visibility || {}) };
  // enforce: select & id always visible and never frozen
  ALWAYS_VISIBLE.forEach((k) => (v[k] = true));
  const frozen = (prefs.frozen || []).filter((c) => !ALWAYS_VISIBLE.has(c));
  return { visibility: v, frozen };
};

const initialState: GridPrefsState = {};

const gridPrefsSlice = createSlice({
  name: "gridPrefs",
  initialState,
  reducers: {
    writeVisibility(
      state,
      { payload }: PayloadAction<{ page: PageKey; table: string; visibility: VisibilityState }>
    ) {
      const { page, table, visibility } = payload;
      state[page] ??= {};
      const current = state[page]![table] ?? { visibility: {}, frozen: [] };
      state[page]![table] = sanitize({ ...current, visibility });
    },
    writeFrozen(
      state,
      { payload }: PayloadAction<{ page: PageKey; table: string; frozen: string[] }>
    ) {
      const { page, table, frozen } = payload;
      state[page] ??= {};
      const current = state[page]![table] ?? { visibility: {}, frozen: [] };
      state[page]![table] = sanitize({ ...current, frozen });
    },
    resetPrefs(state, { payload }: PayloadAction<{ page: PageKey; table: string }>) {
      const { page, table } = payload;
      if (state[page]) delete state[page]![table];
    },
  },
});

export const { writeVisibility, writeFrozen, resetPrefs } = gridPrefsSlice.actions;
export default gridPrefsSlice.reducer;

3------------

"use client";

import { combineSlices, configureStore } from "@reduxjs/toolkit";
import {
  FLUSH, PAUSE, PERSIST, PURGE, REGISTER, REHYDRATE,
  persistReducer, persistStore
} from "redux-persist";
// ⛔️ remove this:
// import storage from "redux-persist/lib/storage";
// ✅ add this:
import { persistentStorage } from "./persistentStorage";

import gridPrefsSlice from "@/state/gridPrefsSlice"; // ✅ NEW

// ...your existing imports (apis, authStateSlice, roleRegionSlice, etc.)

// Persist config
const persistConfig = {
  key: "frame",
  storage: persistentStorage,      // ✅ use Next-safe storage
  whitelist: ["gridPrefs"],        // ✅ persist only what you need
  // or add others if you truly need them persisted
};

// Root reducers
export const rootReducers = combineSlices(
  frameRootApi,
  backendRootApi,
  authStateSlice,
  roleRegionSlice,
  gridPrefsSlice,                  // ✅ add slice
);

const persistedReducer = persistReducer(persistConfig, rootReducers);

export const rootStore = configureStore({
  reducer: persistedReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],
      },
    }).concat(
      authSageMiddleware.middleware,
      frameRootApi.middleware,
      backendRootApi.middleware,
    ),
});

export const storePersistor = persistStore(rootStore);
export type AppRootState = ReturnType<typeof rootStore.getState>;
export type AppRootDispatch = typeof rootStore.dispatch;

export { rootStore as store };

4---------

// FrameDataGridV2.tsx (client)
import React from "react";
import { useDispatch, useSelector } from "react-redux";
import { usePathname } from "next/navigation";
import type { AppRootState } from "@/lib/store";
import { writeVisibility, writeFrozen } from "@/state/gridPrefsSlice";
import type { VisibilityState } from "@tanstack/react-table";
import { useReactTable } from "@tanstack/react-table";

const TABLE_KEY = "mdlGrid"; // stable ID for this grid
const ALWAYS_VISIBLE = new Set(["select", "id"]);

const DEFAULT_HIDDEN: VisibilityState = {
  // your 3 default-hidden columns
  customer_legal_name: false,
  industry: false,
  gcdu_global_id: false,
};

const pageFromPath = (p: string) =>
  p.includes("/reviewer") ? "reviewer" :
  p.includes("/approver") ? "approver" : "viewer";

export default function FrameDataGridV2(/* props */) {
  const pathname = usePathname();
  const pageKey = pageFromPath(pathname);

  const dispatch = useDispatch();
  const persisted = useSelector((s: AppRootState) => s.gridPrefs?.[pageKey]?.[TABLE_KEY]);

  // ---- local state (controlled by TanStack) ----
  const [columnVisibility, setColumnVisibility] = React.useState<VisibilityState>(() => {
    const v = { ...DEFAULT_HIDDEN, ...(persisted?.visibility ?? {}) };
    ALWAYS_VISIBLE.forEach((k) => (v[k] = true));
    return v;
  });

  const [frozenColumnIds, setFrozenColumnIds] = React.useState<string[]>(
    () => (persisted?.frozen ?? []).filter((c) => !ALWAYS_VISIBLE.has(c))
  );

  // Rehydrate once store is ready (after PersistGate)
  React.useEffect(() => {
    if (!persisted) return;
    setColumnVisibility((prev) => {
      const next = { ...DEFAULT_HIDDEN, ...prev, ...(persisted.visibility ?? {}) };
      ALWAYS_VISIBLE.forEach((k) => (next[k] = true));
      return next;
    });
    setFrozenColumnIds((prev) => {
      const merged = persisted.frozen ?? prev ?? [];
      return merged.filter((c) => !ALWAYS_VISIBLE.has(c));
    });
  }, [persisted]);

  // Persist on change
  const onColumnVisibilityChange = (updater: VisibilityState | ((old: VisibilityState) => VisibilityState)) => {
    setColumnVisibility((old) => {
      const next = typeof updater === "function" ? (updater as any)(old) : updater;
      ALWAYS_VISIBLE.forEach((k) => (next[k] = true));
      dispatch(writeVisibility({ page: pageKey as any, table: TABLE_KEY, visibility: next }));
      return { ...next };
    });
  };

  const setFrozen = (next: string[] | ((old: string[]) => string[])) => {
    setFrozenColumnIds((old) => {
      const f = typeof next === "function" ? (next as any)(old) : next;
      const cleaned = f.filter((c) => !ALWAYS_VISIBLE.has(c));
      dispatch(writeFrozen({ page: pageKey as any, table: TABLE_KEY, frozen: cleaned }));
      return cleaned;
    });
  };

  // Example: your existing table init
  const table = useReactTable({
    // data, columns, getCoreRowModel, getPaginationRowModel, ...
    state: {
      columnVisibility,
      // sorting, columnFilters, rowSelection...
    },
    onColumnVisibilityChange, // ✅ hook in
    // other callbacks...
  });

  // Example freeze toggle used by your menu
  const toggleFreeze = (colId: string) => {
    if (ALWAYS_VISIBLE.has(colId)) return;
    setFrozen((old) => (old.includes(colId) ? old.filter((c) => c !== colId) : [...old, colId]));
  };

  // pass frozenColumnIds to your sticky/freeze logic
  return (/* your JSX rendering table */);
}


1-----------------------------

// FrameDataGridV2.tsx
import React from "react";
import isEqual from "fast-deep-equal"; // or write your own shallow/deep compare
import { useSelector, useDispatch } from "react-redux";
import type { AppRootState } from "@/lib/store";
import { writeVisibility, writeFrozen } from "@/lib/mdl/gridPrefsSlice";

// ...your other imports

const TABLE_KEY = "mdlGrid";
const ALWAYS_VISIBLE = new Set(["select", "id"]);

export default function FrameDataGridV2() {
  // persisted prefs (after rehydrate)
  const persisted = useSelector((s: AppRootState) => s.gridPrefs?.viewer?.[TABLE_KEY]);
  const rehydrated = useSelector((s: any) => s._persist?.rehydrated); // redux-persist flag
  const dispatch = useDispatch();

  // local state (what you already have)
  const [columnVisibility, setColumnVisibility] = React.useState<VisibilityState>(() => ({
    customer_legal_name: false,
    industry: false,
    gcdu_global_id: false,
    select: true,
    id: true,
  }));
  const [frozenColumnIds, setFrozenColumnIds] = React.useState<string[]>([]);

  // apply persisted once when it becomes available
  React.useEffect(() => {
    if (!rehydrated || !persisted) return;
    setColumnVisibility((prev) => {
      const next = { ...prev, ...(persisted.visibility ?? {}) };
      ALWAYS_VISIBLE.forEach((k) => (next[k] = true));
      return next;
    });
    setFrozenColumnIds((prev) => {
      const next = persisted.frozen ?? prev ?? [];
      return next.filter((c) => !ALWAYS_VISIBLE.has(c));
    });
  }, [rehydrated, persisted]);

  // ---- IMPORTANT: guard first write so we don't overwrite storage on boot
  const readyToWriteRef = React.useRef(false);
  React.useEffect(() => {
    if (rehydrated) {
      // allow writes only AFTER rehydrate + our state has been merged
      const t = setTimeout(() => (readyToWriteRef.current = true), 0);
      return () => clearTimeout(t);
    }
  }, [rehydrated]);

  const onColumnVisibilityChange = (
    updater: VisibilityState | ((old: VisibilityState) => VisibilityState)
  ) => {
    setColumnVisibility((old) => {
      const next = typeof updater === "function" ? (updater as any)(old) : updater;
      ALWAYS_VISIBLE.forEach((k) => (next[k] = true));

      // write only when rehydrated AND value actually changed from persisted
      if (readyToWriteRef.current) {
        const persistedV = persisted?.visibility ?? {};
        if (!isEqual(next, persistedV)) {
          dispatch(writeVisibility({ page: "viewer", table: TABLE_KEY, visibility: next }));
        }
      }
      return { ...next };
    });
  };

  const setFrozen = (next: string[] | ((old: string[]) => string[])) => {
    setFrozenColumnIds((old) => {
      const f = typeof next === "function" ? (next as any)(old) : next;
      const cleaned = f.filter((c) => !ALWAYS_VISIBLE.has(c));
      if (readyToWriteRef.current) {
        const persistedF = persisted?.frozen ?? [];
        if (!isEqual(cleaned, persistedF)) {
          dispatch(writeFrozen({ page: "viewer", table: TABLE_KEY, frozen: cleaned }));
        }
      }
      return cleaned;
    });
  };

  // pass onColumnVisibilityChange to useReactTable, and use setFrozen/toggleFreeze in your UI
  // ...
}
